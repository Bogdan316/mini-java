options {
//    DEBUG_PARSER = true;
    OUTPUT_DIRECTORY = "/home/bogdan/git/MiniJava/src/main/java/org/example";
    MULTI = true;
    VISITOR = true;
    NODE_PACKAGE = "org.example";
}

PARSER_BEGIN(MiniJavaParser)
    package org.example;
    import javax.swing.*;
    public class MiniJavaParser {
        public static void main(String[] args) throws ParseException {
            MiniJavaParser parser = new MiniJavaParser(System.in);
            ASTProgram p = parser.Program();
            javax.swing.SwingUtilities.invokeLater(new Runnable() {
                        public void run() {
                            JTree j = new JTree(p.jTree);
                            JFrame f = new JFrame();
                            f.add(j);
                            f.setSize(200, 200);
                            f.setVisible(true);
                            System.out.println("here");
                        }
                    });
//            p.dump("");
//            System.out.println("here here");
        }
    }
PARSER_END(MiniJavaParser)

TOKEN : {
    <MAIN: "main">
    |
    <LENGTH: "length">
    |
    <STRING: "String">
    |
    <NEW: "new">
    |
    <INT: "int">
    |
    <BOOLEAN: "boolean">
    |
    <INT_ARR: "int" "[" "]">
    |
    <VOID: "void">
    |
    <PUBLIC: "public">
    |
    <CLASS: "class">
    |
    <EXTENDS: "extends">
    |
    <TRUE: "true">
    |
    <FALSE: "false">
    |
    <THIS: "this">
    |
    <STATIC: "static">
    |
    <RETURN: "return">
    |
    <IF: "if">
    |
    <ELSE: "else">
    |
    <WHILE: "while">
    |
    <SOUT: "System.out.println">
    |
    <INTEGER: (["0"-"9"])+>
    |
    <ID: ["_", "$", "a"-"z", "A"-"Z"](["_", "$", "a"-"z", "A"-"Z", "0"-"9"])*>
}

<*> SKIP : {
    " "
    |
    "\t"
    |
    "\n"
    |
    "\r"
    |
    <"//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
    |
    <"/*" (~["*"])* "*" (~["/"] (~["*"])* "*")* "/">
}

ASTProgram Program():
{}
{
    MainClass() (ClassDecl())* <EOF>
    {return jjtThis;}
}

void MainClass():
{}
{
    <CLASS> <ID> "{" <PUBLIC> <STATIC> <VOID> <MAIN> "(" <STRING> "[" "]" <ID> ")"  "{" (LOOKAHEAD(2) VarDecl())* (Statement())* "}" "}"
}

void ClassDecl():
{}
{
    <CLASS> <ID> (
        "{" (VarDecl())* (MethodDecl())* "}"
        |
        <EXTENDS> <ID> "{" (VarDecl())* (MethodDecl())* "}"
    )
}

void VarDecl():
{}
{
    Type() <ID> ";"
}

void MethodDecl():
{}
{
     <PUBLIC> Type() <ID> "(" FormalList() ")" "{" VarDecl() (Statement())* <RETURN> Exp() ";" "}"
}

void FormalList():
{}
{
    Type() <ID> (FormalRest())*
}

void FormalRest():
{}
{
    "," Type() <ID>
}

void Type():
{}
{
   <INT> ("[" "]")? | <BOOLEAN> | <ID>
}

void Statement():
{}
{
    "{" (Statement())* "}"
    |
    <IF> "(" Exp() ")" Statement() (LOOKAHEAD(2) <ELSE> Statement())?
    |
    <WHILE> "(" Exp() ")" Statement()
    |
    <SOUT> "(" Exp() ")" ";"
    |
    <ID> (
        "=" Exp() ";"
        |
        "[" Exp() "]" "=" Exp() ";"
    )
}

void Exp():
{}
{
    Condition()
}

void Condition():
{}
{
    LogExp()
}

void LogExp():
{}
{
    LogExpTerm() (LOOKAHEAD(2) "||" LogExpTerm())*
}

void LogExpTerm():
{}
{
    LogExpFactor() (LOOKAHEAD(2) "&&" LogExpFactor())*
}

void LogExpFactor():
{}
{
    "!" LogExp() | LOOKAHEAD(3) "(" LogExp() ")" | RelExp() | <TRUE> | <FALSE>
}


void RelExp():
{}
{
    ArExp() (RelOp() ArExp())?
}

void RelOp():
{}
{
    "<" | ">" | "<=" | ">=" | "==" | "!="
}

void ArExp():
{}
{
    Term() (AddOp() Term())*
}

void AddOp():
{}
{
    "+" | "-"
}

void Term():
{}
{
    Factor() (MulOp() Factor())*
}

void MulOp():
{}
{
    "*" | "/"
}

void Factor():
{}
{
    "(" ArExp() ")" | <ID> | <INTEGER>
}
